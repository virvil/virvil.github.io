<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JWT（JSON WEB TOKENS）的使用，无状态token机制]]></title>
    <url>%2F2018%2F09%2F10%2FJWT%EF%BC%88JSON-WEB-TOKENS%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%97%A0%E7%8A%B6%E6%80%81token%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[JWT的优点由于JWT本身是无状态的，仅仅是存储登录授权的信息，可以实现单点登录的功能，因为在多个系统中只要在实现jwt token的时候用同一个密钥进行加密，则可以实现跨平台而登陆。 JWT的缺点==token泄露问题==：由于只要拿到token就可以在不同机器上进行登录，因此只要token泄露出去后用户可以通过登录后改变密码进行窃取。 ==token续签问题==：jwt虽然内置了token过期的功能，但是并没有提供token续签的问题，如果用户在进行重要信息的存储时，刚好token过期了，则导致用户需要重新登录，因此容易造成重要信息丢失，影响客户体验。该项可以通过设计各种策略刷新token过期时间，而session这方面就比jwt好很多，session会自动刷新过期时间，例如是30min过期，但用户在30min内登录session后重新计算过期时间。 JWT token构成一个token包含三个部分（Header，Payload，Signature）header 头部标头通常由两部分组成：令牌的类型，即JWT，以及哈希算法，如HMAC SHA256或RSA。 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; HS256 表示使用了 HMAC-SHA256 来生成签名。接下来对这部分内容使用 Base64Url编码组成了JWT结构的第一部分。 Payload 载荷payload包含三种类型的claim：reserved, public 和 private 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; Reserved claims: 这些claim是JWT预先定义的，在JWT中并不会强制使用它们，而是推荐使用，常用的有 1234567iss: jwt签发者sub: jwt所面向的用户aud: 接收jwt的一方exp: jwt的过期时间，这个过期时间必须要大于签发时间nbf: 定义在什么时间之前，该jwt都是不可用的.iat: jwt的签发时间jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击 Public claims：根据需要定义自己的字段，注意应该避免冲突 Private claims：这些是自定义的字段，可以用来在双方之间交换信息 上述的负载需要经过Base64Url编码后作为JWT结构的第二部分。 Signature 签名jwt的第三部分是一个签证信息，这个签证信息算法如下：base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload)+your-256-bit-secret 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。 JWT简单案例引入依赖包12345&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt; 案例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package jwt;import com.auth0.jwt.JWT;import com.auth0.jwt.JWTVerifier;import com.auth0.jwt.algorithms.Algorithm;import com.auth0.jwt.exceptions.TokenExpiredException;import com.auth0.jwt.interfaces.Claim;import com.auth0.jwt.interfaces.DecodedJWT;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.io.InputStream;import java.util.*;/** * &lt;b&gt;&lt;code&gt;JwtTokenUtil&lt;/code&gt;&lt;/b&gt; * &lt;p/&gt; * Description * &lt;p/&gt; * &lt;b&gt;Creation Time:&lt;/b&gt; 2018\9\10 0010 12:03. * * @author virvil * @since jwtdemo 0.0.1 */public class JwtTokenUtil &#123; /** * The constant logger. */ private static Logger logger = LoggerFactory.getLogger(JwtTokenUtil.class); /** * The constant properties. */ private static Properties properties = new Properties(); /** * The constant signkey. */ private static String signkey = null; /** * The constant algorithm. */ private static Algorithm algorithm = null; /* 加载配置文件内容 */ static &#123; InputStream inputStream = JwtTokenUtil.class.getClassLoader().getResourceAsStream("jwt.properties"); try &#123; properties.load(inputStream); String signkey = properties.getProperty("signkey"); algorithm = Algorithm.HMAC256(signkey); &#125; catch (IOException e) &#123; logger.error("读取配置文件异常",e); &#125; &#125; /** * Get token string. *生成token * @param username the username * @return the string */ public static String getToken(String username)&#123; Calendar calendar = Calendar.getInstance(); //签发时间 Date issueDate = calendar.getTime(); //过期时间 long expires = issueDate.getTime()+Integer.parseInt(properties.getProperty("timeout")); Date expiresDate = new Date(expires); //header Map&lt;String,Object&gt; header = new HashMap&lt;&gt;(); header.put("alg","HS256"); header.put("typ","JWT"); String token = JWT.create() .withHeader(header) //设置header头信息 .withClaim("iss","auth0") //设置payload .withClaim("username",username) .withIssuedAt(issueDate) .withExpiresAt(expiresDate) .sign(algorithm); return token; &#125; /** * Verify token map. *对token进行解密 * @param token the token * @return the map */ public static Map&lt;String,Claim&gt; verifyToken(String token)&#123; JWTVerifier jwtVerifier = JWT.require(algorithm).build(); DecodedJWT verify = null; try &#123; verify = jwtVerifier.verify(token); return verify.getClaims(); &#125;catch (TokenExpiredException ex)&#123; logger.error("token已经过期",ex); &#125;catch (Exception e)&#123; logger.error("登录异常",e); &#125; return null; &#125; /** * The entry point of application. * * @param args the input arguments */ public static void main(String[] args) &#123; String username = "virvil"; String token = getToken(username); //验证token是否正确 Map&lt;String, Claim&gt; claims = verifyToken(token); if (claims!=null)&#123; Claim usernameClaim = claims.get("username"); //此处获得的信息可以到数据库中进行查询，验证是否存在该用户信息，这里我只是简单测试，莫怪 System.out.println(username.equals(usernameClaim.asString())?"token验证成功":"token验证失败"); &#125; //用一个过期的token来验证结果 String token2 = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" + ".eyJpc3MiOiJhdXRoMCIsImV4cCI6MTUzNjU2MTUzNSwiaWF0IjoxNTM2NTYxNTM0LCJ1c2VybmFtZSI6InZpcnZpbCJ9" + ".JNNCERaaApOaoNYV45liZTJ-mF7UIRLNz-EY5tAPC4Q"; verifyToken(token2); &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>jwt</tag>
        <tag>单点登录</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux完全分布式redis集群安装]]></title>
    <url>%2F2018%2F09%2F09%2Flinux%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8Fredis%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[redis集群安装完成后节点如下：（6主6从）192.168.209.128:6001 192.168.209.128:6002 192.168.209.129:6001 192.168.209.129:6002 192.168.209.130:6001 192.168.209.130:6002 192.168.209.128:6003 192.168.209.128:6004 192.168.209.129:6003 192.168.209.129:6004 192.168.209.130:6003 192.168.209.130:6004 //连接客户端 1redis-cli -c -h ip -p port (例如redis-cli -c -h 192.168.209.128 -p 6001) redis下载与解压安装（192.168.209.128，192.168.209.129，192.168.209.129上同样操作）12345cd /usr/local/wget http://download.redis.io/releases/redis-3.2.12.tar.gz //下载tar xzf redis-3.2.12.tar.gz //解压cd redis-3.2.12make install //编译安装 创建存放数据文件在每台机器/usr/local下新建redis-cluster文件夹，在redis-cluster文件夹下创建data文件夹和redis6001 ，redis6002 ，redis6003 ， redis6004文件夹。然后再在data文件夹下分别新建6001,6002,6003,6004四个文件，用于存放数据等 12345mkdir /usr/local/redis-clustercd /usr/local/redis-clustermkdir redis6001 redis6002 redis6003 redis6004 //存放各个节点的配置文件cd /usr/local/redis-cluster/datamkdir 6001 6002 6003 6004 //存放各个节点的数据 修改配置文件将/usr/local/redis-3.2.12下的redis.conf配置文件分别复制到redis600文件夹下，并将redis600下的redis.conf做如下修改（每个redis600*下的redis.conf都需修改） 1234567891. daemonize yes2. port600* （对应每个机器的端口号，在此分别设置为6001，6002，6003，6004）3. bind 0.0.0.04. cluster-enabled yes (开启集群模式)5. cluster-config-file nodes-600*.conf (最好跟端口号对应，方便识别，在此分别设置为6001，6002，6003，6004)6. cluster-node-timeout 50007. appendonly yes8. protect-mode no9.dir /usr/local/redis-cluster/data/6001/ (在此分别设置为6001，6002，6003，6004) 安装ruby由于redis集群需要ruby命令，需要安装ruby 1231. yum install ruby2. yum install rubygems3. gem install redis ==执行以上命令可能会因为Ruby**版本过低，而执行失败== ruby版本低 导入public 公钥，命令如下（直接复制即可） gpg2 –recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 redis requires Ruby version &gt;= 2.2.2的报错，查了资料发现是Centos默认支持ruby到2.0.0，可gem 安装redis需要最低是2.2.2 解决办法是 先安装rvm，再把ruby版本提升至2.5.1，需要安装如下包 1.安装curl 1sudo yum install curl ==可能出现的问题：== curl: (35) SSL connect error问题处理 无法在服务器使用curl命令访问https域名,原因是nss版本有点旧了，使用以下命令更新一下，重新安装curl即可！ 1yum -y update nss 2.安装RVM 123curl -L get.rvm.io | bash -s stable source /usr/local/rvm/scripts/rvm 3.查看rvm库中已知的ruby版本，并安装ruby 1234567rvm list known //查看rvm库中已知的ruby版本rvm install 2.5.1 //安装rubyrvm use 2.5.1 //使用一个ruby版本ruby --version //查看当前版本 4.再安装redis就可以了 1gem install redis 在每台机器启动服务器节点1234/usr/local/bin/redis-server /usr/local/redis-cluster/redis6001/redis.conf/usr/local/bin/redis-server /usr/local/redis-cluster/redis6002/redis.conf/usr/local/bin/redis-server /usr/local/redis-cluster/redis6003/redis.conf/usr/local/bin/redis-server /usr/local/redis-cluster/redis6004/redis.conf 向集群中添加节点（在任一一台机器上执行以下命令即可，（–replicas 1代表一主一从，–replicas 2代表一主两从）） 1/usr/local/redis-3.2.12/src/redis-trib.rb create --replicas 1 192.168.209.128:6001 192.168.209.128:6002 192.168.209.129:6001 192.168.209.129:6002 192.168.209.130:6001 192.168.209.130:6002 192.168.209.128:6003 192.168.209.128:6004 192.168.209.129:6003 192.168.209.129:6004 192.168.209.130:6003 192.168.209.130:6004 连接客户端（以下任一命令执行都可）1234/usr/local/bin/redis-cli -c -h 192.168.209.128 -p 6001/usr/local/bin/redis-cli -c -h 192.168.209.128 -p 6002/usr/local/bin/redis-cli -c -h 192.168.209.128 -p 6003/usr/local/bin/redis-cli -c -h 192.168.209.128 -p 6004 关闭某个节点命令1234/usr/local/bin/redis-cli -c -h 192.168.209.128 -p 6001 shutdown/usr/local/bin/redis-cli -c -h 192.168.209.128 -p 6002 shutdown/usr/local/bin/redis-cli -c -h 192.168.209.128 -p 6003 shutdown/usr/local/bin/redis-cli -c -h 192.168.209.128 -p 6004 shutdown 清空所有节点数据123456789101112redis-cli -h 192.168.209.128 -p 6004 -c flushallredis-cli -h 192.168.209.129 -p 6002 -c flushallredis-cli -h 192.168.209.130 -p 6001 -c flushallredis-cli -h 192.168.209.130 -p 6004 -c flushallredis-cli -h 192.168.209.128 -p 6003 -c flushallredis-cli -h 192.168.209.130 -p 6002 -c flushallredis-cli -h 192.168.209.128 -p 6001 -c flushallredis-cli -h 192.168.209.129 -p 6003 -c flushallredis-cli -h 192.168.209.129 -p 6001 -c flushallredis-cli -h 192.168.209.130 -p 6003 -c flushallredis-cli -h 192.168.209.129 -p 6004 -c flushallredis-cli -h 192.168.209.128 -p 6002 -c flushall 免密登录（可有可无）123ssh-keygen -t rsassh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.209.128ssh 192.168.209.128 如果redis集群启动失败，（将/usr/local/redis-cluster/data下的文件都删除然后用一下方法进行测试）：安装telnet12yum install telnet-serveryum install telnet.* 测试连接（一定得测通）1telnet ip port //测试连接（例如：telnet 192.168.209.128 6001） 如何测不通，有如下两种解决方案，关闭防火墙，或者打开端口1.关闭防火墙service iptables status //查看防火墙状态 service iptables stop //关掉防火墙则所有端口都默认开放 2.打开端口端口管理#开启6001端口（redis有个不成文规则，开启6001端口，就必须开启16001端口，即在原有端口+10000） 123456789101112/sbin/iptables -I INPUT -p tcp --dport 6001 -j ACCEPT /sbin/iptables -I INPUT -p tcp --dport 6002 -j ACCEPT /sbin/iptables -I INPUT -p tcp --dport 6003 -j ACCEPT /sbin/iptables -I INPUT -p tcp --dport 6004 -j ACCEPT/sbin/iptables -I INPUT -p tcp --dport 16001 -j ACCEPT /sbin/iptables -I INPUT -p tcp --dport 16002 -j ACCEPT/sbin/iptables -I INPUT -p tcp --dport 16003 -j ACCEPT /sbin/iptables -I INPUT -p tcp --dport 16004 -j ACCEPT/etc/rc.d/init.d/iptables save #保存配置 /etc/rc.d/init.d/iptables restart #重启服务 查看已开放端口 /etc/init.d/iptables status 如果以上都没问题，则重新执行以下命令即可： 1234567//在每台机器启动服务器节点/usr/local/bin/redis-server /usr/local/redis-cluster/redis6001/redis.conf/usr/local/bin/redis-server /usr/local/redis-cluster/redis6002/redis.conf/usr/local/bin/redis-server /usr/local/redis-cluster/redis6003/redis.conf/usr/local/bin/redis-server /usr/local/redis-cluster/redis6004/redis.conf//远程集群中添加节点（在任一一台机器上执行以下命令即可，（--replicas 1代表一主一从，--replicas 2代表一主两从））/usr/local/redis-3.2.12/src/redis-trib.rb create --replicas 1 192.168.209.128:6001 192.168.209.128:6002 192.168.209.129:6001 192.168.209.129:6002 192.168.209.130:6001 192.168.209.130:6002 192.168.209.128:6003 192.168.209.128:6004 192.168.209.129:6003 192.168.209.129:6004 192.168.209.130:6003 192.168.209.130:6004]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>集群</tag>
        <tag>完全分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop]]></title>
    <url>%2F2018%2F09%2F08%2Fhadoop%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
